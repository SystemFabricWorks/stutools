= spit(1)
Stuart Inglis, Ph.D.
:doctype: manpage
:man manual: spit manual
:man source: spit 1.1
:page-layout: base

== NAME

spit - Stu's powerful I/O tester

== SYNOPSIS

*spit* [_OPTION_]... _FILE_...

== DESCRIPTION

The spit(1) performs various I/O. The *-c* command spins up a command
string on a dedicated thread with an AIO context per thread.

== OVERVIEW

*spit* [GLOBAL OPTIONS] -c _commands_ -c _commands_ -c _commands_

== GLOBAL OPTIONS

 *f device*::
   Specific a single device (e.g. -f /dev/ram0)

 *G size*::
   Limit the positions to a maximum of *size* GiB (e.g. -G 32)

 *I filename*::
   Specific a file that contains a list of device names (e.g. -f devices.txt)

 *j N*::
   Multiply the number of commands (*-c*) by N. (e.g. -j 8)

 *t s*::
   Limit the execution to *s* seconds (e.g. -t 30)

 *p precondition_options*::
  Before executing any commands, run the precondition write
  commands. Defaults to 4k writes. Options include: *-p Gn*, *-p Gs1* for
  sequential, *-p Gk8* for 8 KiB writes. (e.g. -p G32)
   
 *O filename*::
   Specifies a list of raw devices, matched with the *-f* option shows
   device read/write amplification. (e.g. -f /dev/md0 -O devices.txt)

== COMMAND OPTIONS

A command is a single contiguous string. Spaces are ignored if the
entire string is quoted. An example of a command string may look like:
*spit* -c *rk64P1000s3* -f /dev/device

The command options are described below:

 *r*::
   Performs reads

 *w*::
   Performs writes

 *Glow-high*::
   Limit the position range to *low* to *high* GiB. (e.g. G2-3)
 
 *kN* or *klowBS-highBS*::
   Block size or _lowblocksize_ to _highblocksize_ range. (e.g. k4-128)

 *n*::
   Use random positions with replacement 
   
 *qN*::
   Queue depth

 *RN*::
   Seed

 *sN*::
   number of contiguous sequence regions. *s0* means random, *s1* means
   a single linear stream, *s32* means 32 contigous stream.

 *z*::
   Start sequential positions from block 0

 *Zn*::
   Start sequential positions from block *n*

=== Scale/position commands

 *Pn*::
   Limit the number of positions to *n*

 *xn*::
   Multiply the number of positions by *n*

=== Timing commands

 *Bn*::
   Before the command starts, wait *n* seconds

 *Wn*::
   Wait for *n* seconds between iterations

 *Tn*::
   Limits the thread/command to *n* seconds

 *Xn*::
   Instead of time based, iterate until the positions have been processed
   *n* times.

== Benchmarking

=== Sequential reads / writes

In the following commands, replace *r* with *w* for writes.

*spit* -f /dev/device -c rk64

  Performs a single thread/job that performs reads, with 64 KiB reads

*spit* -f /dev/device -c rk64 -j 32

  Create 32 threads, with a single contigous read inside each thread

*spit* -f /dev/device -c r32k64

  Create a single threads, break the device into 32 contiguous regions


=== Random read / writes

*spit* -f /dev/device -c rs0

  Performs a single thread/job, random 4KiB reads

*spit* -f /dev/device -c rs0 -j 32

  Creates 32 threads, reads random 4KiB reads

*spit* -f /dev/device -c rs0 -j 32 -G1

  Creates 32 threads, reads randomly 4KiB reads, limited to first 1 GiB.
  For devices with cache these operations should be cached.

*spit* -f /dev/device -c rP10000

  Read from the first 10,000 positions (4 KiB) blocks in a device.


=== Mixing reads/writes

*spit* -f /dev/device -c mP10000 -c rk64

  Two threads, one reading/write metadata to 10,000 positions. Another
  thread performing sequential reads.

*spit* -f /dev/device -c w -c r

  Two threads, both sequential, one reading, one writing.

*spit* -f /dev/device -c ws0 -c rs0

  Two threads, both random, one reading, one writing.

*spit* -f /dev/device -c ws1G0-100 -c ws0G100-200

  On a 200 GiB perform linear writes in the first half and
  random writes on the second half.

=== SNIA latency graphs

*spit* -p G -f /dev/device -c rs0n -t 3600

  This will run a preconditioning step, 2x the size of the device LBA.
  The proceed with a random 4k read pattern, reordering after each
  pass.  The output will be written 'spit-latency-read.gnu' which can
  be loaded into gnuplot.

== EXIT STATUS

*0*::
  Success.

*non-zero*::
  Failure (syntax of usage error).
  

== BUGS

Bugs will be rewarded by choc fish.




  